const dictionary =
	[
        undefined, "stream:stream", undefined, undefined, undefined, // 0-4
        "1", "1.0", "ack", "action", "active", "add", "all", "allow", "apple", "audio", "auth", "author", "available", //5-17
        "bad-request", "base64", "Bell.caf", "bind", "body", "Boing.caf", // 18-23
        "cancel", "category", "challenge", "chat", "clean", "code", "composing", "config", "conflict", "contacts", "create", "creation", // 24-35
        "default", "delay", "delete", "delivered", "deny", "DIGEST-MD5", "DIGEST-MD5-1", "dirty", // 36-43
        "en", "enable", "encoding", "error", "expiration", "expired", // 44-49
        "failure", "false", "favorites", "feature", "field", "free", "from", // 50-56
        "g.us", "get", "Glass.caf", "google", "group", "groups", "g_sound", // 57-63
        "Harp.caf", "http://etherx.jabber.org/streams", "http://jabber.org/protocol/chatstates", // 64-66
        "id", "image", "img", "inactive", "internal-server-error", "iq", "item", "item-not-found", // 67-74
        "jabber:client", "jabber:iq:last", "jabber:iq:privacy", "jabber:x:delay", "jabber:x:event", "jid", "jid-malformed", // 75-81
        "kind", // 82
        "leave", "leave-all", "list", "location", // 83-86
        "max_groups", "max_participants", "max_subject", "mechanism", "mechanisms", "media", "message", "message_acks", "missing", "modify", // 87-96
        "name", "not-acceptable", "not-allowed", "not-authorized", "notify", // 97-101
        "Offline Storage", "order", "owner", "owning", // 102-105
        "paid", "participant", "participants", "participating", "particpants", "paused", "picture", "ping", "PLAIN", "platform", "presence", // 106-116
        "preview", "probe", "prop", "props", "p_o", "p_t", // 117-122
        "query", // 123
        "raw", "receipt", "receipt_acks", "received", "relay", "remove", "Replaced by new connection", "request", "resource", "resource-constraint", // 124-133
        "response", "result", "retry", "rim", // 134-137
        "s.whatsapp.net", "seconds", "server", "session", "set", "show", "sid", "sound", "stamp", "starttls", "status", "stream:error", // 138-149
        "stream:features", "subject", "subscribe", "success", "system-shutdown", "s_o", "s_t", // 150-156
        "t", "TimePassing.caf", "timestamp", "to", "Tri-tone.caf", "type", // 157-162
        "unavailable", "uri", "url", "urn:ietf:params:xml:ns:xmpp-bind", "urn:ietf:params:xml:ns:xmpp-sasl", "urn:ietf:params:xml:ns:xmpp-session", // 163-168
        "urn:ietf:params:xml:ns:xmpp-stanzas", "urn:ietf:params:xml:ns:xmpp-streams", "urn:xmpp:delay", "urn:xmpp:ping", "urn:xmpp:receipts", // 169-173
        "urn:xmpp:whatsapp", "urn:xmpp:whatsapp:dirty", "urn:xmpp:whatsapp:mms", "urn:xmpp:whatsapp:push", // 174-177
        "value", "vcard", "version", "video", // 178-181
        "w", "w:g", "w:p:r", "wait", // 182-185
        "x", "xml-not-well-formed", "xml:lang", "xmlns", "xmlns:stream", "Xylophone.caf", // 186-191
        "account","digest","g_notify","method","password","registration","stat","text","user","username","event","latitude","longitude", // 192-204
        "true", "after", "before", "broadcast", "count", "features", "first", "index", "invalid-mechanism", undefined, // 205-214
        "max", "offline", "proceed", "required", "sync", "elapsed", "ip", "microsoft", "mute", "nokia", "off", "pin", // 215-226
        "pop_mean_time", "pop_plus_minus", "port", "reason", "server-error", "silent", "timeout", "lc", "lg", "bad-protocol", // 227-236
        "none", "remote-server-timeout", "service-unavailable", "w:p", "w:profile:picture", "notification", // 237-242
    ];

//  0 66 248 8 93 160 250 252 11 49 55 48 55 57 57 50 53 50 51 51 138 162 27 67 252 11 49 50 51 52 53 54 55 56 57 45 50 248 2 248 4 186 189 79 248 1 248 1 140 248 2 22 252 14 84 101 115 116 32 77 101 115 115 97 103 101 32 49
//  0 66 248 8 93 160 250 252 11 49 55 48 55 57 57 50 53 50 51 51 138 162 27 67 252 11 49 50 51 52 53 54 55 56 57 45 51 248 2 248 4 186 189 79 248 1 248 1 140 248 2 22 252 14 84 101 115 116 32 77 101 115 115 97 103 101 32 49

var net = require('net');
var base64 = require('./base64');
var crypto = require('crypto');
var fs = require('fs');
var pack = require('./pack');

function md5(x) {
    return crypto.createHash('md5').update(x).digest("hex");
}

function hex2str(hex) {
    var str = '';
    for(var i = 0; i < hex.length; i += 2)
        str += String.fromCharCode(parseInt(hex.substr(i, 2), 16));
    return str;
}

function _hex(in_int)
{
    console.log("_hex", in_int, in_int.toString(16));
    return in_int.toString(16);
}

function splitBuffer(buf, char) {
    var arr = [], p = 0;
    for(var i = 0; i <= buf.length; i++) {
        if(buf[i] !== char) continue;
        if(i === 0) {
            p = 0;
            i = 0;
        }
        arr.push(buf.slice(p, i));
        p = i + 1;
    }
    arr.push(buf.slice(p));
    return arr;
}

function array_shift (inputArr) {
    // Pops an element off the beginning of the array  
    // 
    // version: 1109.2015
    // discuss at: http://phpjs.org/functions/array_shift
    // +   original by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)
    // +   improved by: Martijn Wieringa
    // %        note 1: Currently does not handle objects
    // *     example 1: array_shift(['Kevin', 'van', 'Zonneveld']);
    // *     returns 1: 'Kevin'
    var props = false,
        shift = undefined,
        pr = '',
        allDigits = /^\d$/,
        int_ct = -1,
        _checkToUpIndices = function (arr, ct, key) {
            // Deal with situation, e.g., if encounter index 4 and try to set it to 0, but 0 exists later in loop (need to
            // increment all subsequent (skipping current key, since we need its value below) until find unused)
            if (arr[ct] !== undefined) {
                var tmp = ct;
                ct += 1;
                if (ct === key) {
                    ct += 1;
                }
                ct = _checkToUpIndices(arr, ct, key);
                arr[ct] = arr[tmp];
                delete arr[tmp];
            }
            return ct;
        };
 
 
    if (inputArr.length === 0) {
        return null;
    }
    if (inputArr.length > 0) {
        return inputArr.shift();
    }
}

var EventEmitter = require('events').EventEmitter;

if(process.version == "v0.2.3") {
    util = {};
    util.inherits = require('sys').inherits;
} else {
    util = require('util');
}

var waapi = function(username, password) {
    console.log("waapi constructed for " + username + ", " + password);
    this.loginInfo = {
        username: username,
        password: password,
        resource: "iPhone-2.6.9-5222", // Symbian-2.6.61-443
        domain: "s.whatsapp.net",
    };
    this.socket = net.createConnection(5222, 'bin-short.whatsapp.net');
    this.writer = new BinTreeNodeWriter(this.socket, dictionary);
    this.reader = new BinTreeNodeReader(this.socket, dictionary);
    
    this.socket.addListener('connect', function() {
        console.log("*** socket connected");
        this.writer.streamStart(this.loginInfo.domain, this.loginInfo.resource);
        //this.sendFeatures();
        // TODO: we need to figure out what the actual negotiation is, rather than feeding it the canned thing.
        //var node = new ProtocolTreeNode("stream:features", undefined, [new ProtocolTreeNode("receipt_acks", undefined, undefined) ]);
        //console.log("feature node: " + node);
        //this.writer.write(node);    
        
        //this.sendAuth();
        //node = new ProtocolTreeNode("auth", { "xmlns":"urn:ietf:params:xml:ns:xmpp-sasl", "mechanism":"DIGEST-MD5-1"});
        //this.writer.write(node);
        //this.reader.streamStart(this.socket, dictionary);
        
        //this.readFeaturesAndChallenge();
        //var server_supports_recept_acks = true;
        /*var root = this.reader.nextTree();
        while(root) {
            console.log("looping node with tag " + root.tag);
            root = this.reader.nextTree();
        }*/
            
    }.bind(this));
    this.socket.addListener('data', function(data) {
        console.log("*** data received: " + data);
    });
    
    this.reader.on('challenge', function(node) {
        var response = base64.base64.decode(node.data.toString("binary"));
        console.log("**** RECEIVED CHALLENGE '" + node.data + "'");
        console.log("**** Challenge decode: '" + base64.base64.decode(node.data.toString("binary")) + "'");
        var node = new ProtocolTreeNode("response", { "xmlns": "urn:ietf:params:xml:ns:xmpp-sasl" }, undefined, base64.base64.encode(response));
        console.log("Responding with node: " + node);
        this.writer.write(node);
    }.bind(this));
    this.socket.addListener('data', this.reader.recv.bind(this.reader));
    
    this.socket.addListener('error', function() {
        console.log("*** error");
    });
    this.socket.addListener('close', function() {
        console.log("*** close");
    });
};

waapi.prototype = {};

waapi.prototype.sendFeatures = function() {
    var node = new ProtocolTreeNode("stream:features", undefined, [new ProtocolTreeNode("receipt_acks", undefined, undefined) ]);
    console.log("feature node: " + node);
    this.writer.write(node);    
};

waapi.prototype.sendAuth = function() {
    var node = new ProtocolTreeNode("auth", { "xmlns":"urn:ietf:params:xml:ns:xmpp-sasl", "mechanism":"DIGEST-MD5-1"});    
};

waapi.prototype.readFeaturesAndChallenge = function() {
    var server_supports_recept_acks = true;
    var root = this.reader.nextTree();
    while(root) {
        console.log("looping node with tag " + root.tag);
        root = this.reader.nextTree();
    }
}

util.inherits(waapi, EventEmitter);

waapi.prototype.login = function() {
    this.socket = net.createConnection(5222, 'bin-short.whatsapp.net');
    this.socket.addListener('connect', function() {
        this.emit('connected');
        this.step1 = true;
        //var init = Buffer("WA\x01\x00\x00\x19\xf8\x05\x01\xa0\x8a\x84\xfc\x11" + "iPhone-2.6.9-5222" + "\x00\x08\xf8\x02\x96\xf8\x01\xf8\x01\x7e\x00\x07\xf8\x05\x0f\x5a\x2a\xbd\xa7", "binary");
        var init = Buffer("WA\x01\x00");
        console.log("writing init:", init.length, init, ":", init.toString("ascii"), init);
        this.socket.write(init);        
    }.bind(this));
};

exports.waapi = waapi;

var BinTreeNodeReader = function(inputstream, dictionary) {
    this.tokenMap = dictionary;
    this.rawIn = inputstream;
    this.inn = Buffer("");
    this.buf = Buffer(1024);
    this.bufSize = 0;
    this.readSize = 1;
    this.pointer = 0;
    this.bufPointer = 0;
    this.streamStarted = false;
    this.receivedChallenge = false;
}

BinTreeNodeReader.prototype = { };

util.inherits(BinTreeNodeReader, EventEmitter);

BinTreeNodeReader.prototype.streamStart = function() {
    //var stanzaSize = this.readInt16(this.rawIn, 1);
    //this.fillBuffer(stanzaSize);
    //var tag = this.inn.read()
}

BinTreeNodeReader.prototype.recv = function(data) {
    console.log("BTNR recv: " + data);
    console.log("Hex dump: " + data.toString("hex"));
    //this.buf = Buffer(this.buf + data, "binary");
    this.inn = Buffer(data, "binary"); // it probably already is a fucking buffer.. derp.
    if(!this.streamStarted) {
        console.log("Looking for STREAM_START");
        this.pointer = 0;
        var stanzaSize = this.readInt16();
        console.log("StanzaSize = " + stanzaSize);
        var tag = this.inn[this.pointer++];
        console.log("tag = " + tag);
        var size = this.readListSize(tag);
        console.log("size = " + size);
        tag = this.inn[this.pointer++];
        if(tag != 1) {
            throw("Expecting STREAM_START, tag = 1! tag=" + tag);
        }
        var attribCount = (size - 2 + size % 2) / 2;
        var attributes = this.readAttributes(attribCount);
        console.log("Stream Start received, attributes=" + JSON.stringify(attributes)); // { "from": "s.whatsapp.net" }
        this.streamStarted = true;
        //this.pointer+=2;
    } else {
        this.pointer = 0;
    }
    while(this.pointer < this.inn.length) {
        if(this.inn[this.pointer] === 0) {
            this.pointer++;
            continue;
        }
        console.log("entering while " + this.pointer + " " + this.inn.length);
        var packetsize = this.inn[this.pointer++];
        console.log("packet size=", packetsize);
        var b = this.inn[this.pointer++];
        console.log("first byte of packet=", b);
        var size = this.readListSize(b);
        console.log("list size=", size);
        b = this.inn[this.pointer++];
        console.log("next b=", b);
        if(b == 2) {
            return undefined;
        }
        var tag = this.readString(b);
        if(size == 0 || !tag) {
            throw("0 size list or null tag");
        }
        var attribCount = (size - 2 + size % 2) / 2;
        var attribs = this.readAttributes(attribCount);
        
        var node;
        if(size % 2 == 1) {
            node = new ProtocolTreeNode(tag, attribs);
            this.emit('node', node);
            console.log("received node " + node);
            this.pointer++;
            continue;
        }
        b = this.inn[this.pointer++];
        if(this.isListTag(b)) {
            node = new ProtocolTreeNode(tag, attribs, this.readList(b));
            console.log("received list " + node);
            this.emit('node', node);
            this.pointer++;
            continue;
        }
        node = new ProtocolTreeNode(tag, attribs, undefined, this.readString(b));
        console.log("received node 2: " + typeof node + " " + node);
        if(node.tag == "challenge") {
            this.emit('challenge', node);
        } else {
            this.emit('node', node);
        }
        this.pointer++;
    }
    console.log("exiting while " + this.pointer + " " + this.inn.length);
}

BinTreeNodeReader.prototype.isListTag = function(b) {
    return b == 248 || b == 0 || b == 249;
}

BinTreeNodeReader.prototype.readList = function(token) {
    console.log("readList " + token);
    var size = this.readListSize(token);
    var listx = [];
    for(var i = 0; i < size; i++) {
        listx.push(this.nextTreeInternal());
    }
    return listx;
}

BinTreeNodeReader.prototype.nextTreeInternal = function() {
    console.log("nextTreeInternal");
    var b = this.inn[this.pointer++];
    var size = this.readListSize(b);
    b = this.inn[this.pointer++];
    var tag = this.readString(b);
    if(size == 0 || !tag) {
        throw("nextTree found 0 size list or null tag");
    }
    var attribCount = (size - 2 + size % 2) / 2;
    var attribs = this.readAttributes(attribCount);
    if(size % 2 == 1) {
        return new ProtocolTreeNode(tag, attribs);
    }
    b = this.inn[this.pointer++];
    if(this.isListTag(b)) {
        return new ProtocolTreeNode(tag, attribs, this.readList(b));
    } else {
        return new ProtocolTreeNode(tag, attribs, undefined, this.readString(b));
    }
}

BinTreeNodeReader.prototype.readInt8 = function() {
    return this.inn.toString("binary").charCodeAt(this.pointer++);
};

BinTreeNodeReader.prototype.readInt16 = function() {
    console.log("readInt16 inn=", this.inn.toString());
    var str = this.inn.toString("binary");
    var intTop = str.charCodeAt(this.pointer++);
    var intBot = str.charCodeAt(this.pointer++);
    console.log("readInt16 " + intTop + " " + intBot);
    return (intTop << 8) + intBot;
};

BinTreeNodeReader.prototype.readInt24 = function() {
    var str = this.inn.toString("binary");
    var int1 = str.charCodeAt(this.pointer++);
    var int2 = str.charCodeAt(this.pointer++);
    var int3 = str.charCodeAt(this.pointer++);
    return (int1 << 16) + (int2 << 8) + (int3 << 0);
};

BinTreeNodeReader.prototype.readListSize = function(token) {
    console.log("readListSize " + token);
    var size = 0;
    if(token !== 0) {
        if(token == 248) {
            size = this.readInt8();
        } else if(token == 249) {
            size = this.readInt16();
        } else {
            throw("invalid list size in readListSize token " + token);
        }
    }
    return size;
};

BinTreeNodeReader.prototype.readAttributes = function(attribCount) {
    console.log("readAttributes " + attribCount);
    var attribs = {};
    for(var i = 0; i < attribCount; i++) {
        var key = this.readString(this.inn[this.pointer++]);
        var value = this.readString(this.inn[this.pointer++]);
        attribs[key] = value;
    }
    return attribs;
}

BinTreeNodeReader.prototype.getToken = function(token) {
    console.log("getToken " + token + ": " + this.tokenMap[token]);
    return this.tokenMap[token];
}

BinTreeNodeReader.prototype.readString = function(token) {
    console.log("readString " + token);
    if(token == -1) {
        throw("-1 token in readString");
    }
    if(token > 4 && token < 245) {
        return this.getToken(token);
    }
    if(token == 0) {
        return undefined;
    }
    if(token == 252) {
        var size8 = this.readInt8();
        var buf8 = Buffer(size8);
        this.inn.copy(buf8, 0, this.pointer, size8 + this.pointer);
        this.pointer += size8;
        return buf8;
    }
    if(token == 253) {
        var size24 = this.readInt24();
        buf24 = Buffer(size24);
        this.inn.copy(buf24, 0, this.pointer, size24 + this.pointer);
        this.pointer += size24;
        return buf24;
    }
    if(token == 254) {
        token = this.inn[this.pointer++];
        return this.getToken(245 + token);
    }
    if(token == 250) {
        var user = this.readString(this.inn[this.pointer++]);
        var server = this.readString(this.inn[this.pointer++]);
        if(user && server) {
            return user + "@" + server;
        } else if(server) {
            return server;
        } else {
            throw("readString couldn't build jid");
        }
    }
    throw("readString couldn't match token?");
}

var ProtocolTreeNode = function(tag, attributes, children, data) {
    console.log("ProtocolTreeNode: " + tag + " attr: " + JSON.stringify(attributes) + " data: " + data);
    this.tag = tag;
    this.attributes = attributes;
    this.children = children;
    this.data = data;
};

ProtocolTreeNode.prototype = { };

ProtocolTreeNode.prototype.toString = function() {
    var out = "<" + this.tag;
    if(this.attributes) {
        for(var x in this.attributes) {
            out += " " + x + "=" + this.attributes[x];
        }
    }
    out += ">\n";
    if(this.data) {
        out += this.data;
    }
    if(this.children) {
        for(var c in this.children) {
            out += this.children[c].toString();
        }
    }
    out += "</" + this.tag + ">\n";
    return out;
}

var BinTreeNodeWriter = function(stream, dictionary) {
    console.log("nodewriter constructor");
    this.realOut = stream;
    this.outputBuffer = Buffer("");
    for(var x = 0; x < dictionary.length; x++) {
        //if(dictionary[x]) {
            this.tokenMap[dictionary[x]] = x; // why the hell do they do this?
        //}
    }
    console.log("BinTreeNodeWriter: tokenMap created");
};

BinTreeNodeWriter.prototype = {
    STREAM_START: "\x01",
    STREAM_END: "\x02",
    LIST_EMPTY: "\x00",
    LIST_8: "\xF8", // 248
    LIST_16: "\xF9", // 249
    JID_PAIR: "\xFA", // 250
    BINARY_8: "\xFC", // 252
    BINARY_24: "\xFD", // 253
    TOKEN_8: "\xFE", // 254
    tokenMap: {},
    outputBuffer: Buffer("")
};
// W A 01 00 00 06 fd 05 01 fd fd fd 00 08 fd 02 fd fd 01 fd 01 7e 00 07 fd 05 0f fd fd 5a 2a
// W A 01 00 00 19 f8 05 01 a0 8a 84 fc 11 00 08 f8 02 96 f8 01 7e 00 07 f8 05 0f 5a 2a bd a7
BinTreeNodeWriter.prototype.streamStart = function(domain, resource) {
    console.log("starting stream for " + domain + "@" + resource);
    /*this.realOut.write("WA\x01\x00");
    var streamOpenAttributes = { "to": domain, "resource": resource };
    this.writeListStart(5); // to + domain + resource + resource + 1 ?
    this.outputBuffer += Buffer("\x01", "binary");
    this.writeAttributes(streamOpenAttributes);*/
    this.outputBuffer = Buffer("WA\x01\x00\x00\x19\xf8\x05\x01\xa0\x8a\x84\xfc\x11" + "iPhone-2.6.9-5222" + "\x00\x08\xf8\x02\x96\xf8\x01\xf8\x01\x7e\x00\x07\xf8\x05\x0f\x5a\x2a\xbd\xa7", "binary");
    this.realOut.write(this.outputBuffer);
    this.outputBuffer = Buffer("");
    //this.flushBuffer(false, false); // bool trap!
};

BinTreeNodeWriter.prototype.write = function(node, needsFlush) {
    console.log("writer: write");
    if(!node) {
        this.outputBuffer += Buffer("\x00", "binary");
    } else {
        this.writeInternal(node);
    }
    this.flushBuffer(needsFlush);
};

BinTreeNodeWriter.prototype.flushBuffer = function(flushNetwork, noSize) {
    this.outputBuffer = Buffer(this.outputBuffer, "binary");
    console.log("outputBuffer is a " + typeof this.outputBuffer);
    var size = this.outputBuffer.length;
    if(size & 0xFFFF0000) {
        throw("Buffer too large: " + size);
    }
    //this.writeInt16(size, this.realOut);
    if(!noSize)
        this.outputBuffer = Buffer( String.fromCharCode((size & 0xFF00) >> 8) + String.fromCharCode((size & 0xFF) >> 0) + this.outputBuffer, "binary");
    this.realOut.write(this.outputBuffer);
    console.log("writer: flushBuffer " + this.outputBuffer.toString("binary") + ": " + this.outputBuffer.toString("hex"));    
    this.outputBuffer = Buffer("");
    if(flushNetwork)
        this.realOut.flush(); // does this even exist?
};

BinTreeNodeWriter.prototype.writeInternal = function(node) {
    console.log("writeInternal " + JSON.stringify(node));
    var c = 0;
    for(var a in node.attributes) {
        c++;
    }
    var x = 1 + (node.attributes ? c * 2 : 0) + (node.children ? 1 : 0) + (node.data ? 1 : 0);
    this.writeListStart(x);
    this.writeString(node.tag);
    this.writeAttributes(node.attributes);
    if(node.data) {
        this.writeBytes(node.data);
    }
    if(node.children) {
        this.writeListStart(node.children.length);
        for(var c in node.children) {
            this.writeInternal(node.children[c]);
        }
    }
};

BinTreeNodeWriter.prototype.writeAttributes = function(attributes) {
    console.log("writeAttributes " + JSON.stringify(attributes));
    if(attributes) {
        for(var x in attributes) {
            this.writeString(x);
            this.writeString(attributes[x]);
        }
    }
};

BinTreeNodeWriter.prototype.writeBytes = function(bytes) {
    console.log("writeBytes " + bytes.length);
    var length = bytes.length;
    if(length > 255) {
        this.outputBuffer += Buffer("\xFD", "binary"); // 253
        this.writeInt24(length);
    } else {
        this.outputBuffer += Buffer("\xFC", "binary"); // 252
        this.writeInt8(length);
    }
    console.log("buffer: " + bytes);
    this.outputBuffer += Buffer(bytes + "\x00", "binary");
};

BinTreeNodeWriter.prototype.writeInt8 = function(v) {
    console.log("writeInt8 " + v + " " + (v & 0xFF) + " " + String.fromCharCode(v & 0xFF));
    this.outputBuffer += Buffer( String.fromCharCode(v & 0xFF) );
};

BinTreeNodeWriter.prototype.writeInt16 = function(v, outputToStream) {
    console.log("writeInt16 " + v);
    var buf = Buffer( String.fromCharCode((v & 0xFF00) >> 8) + String.fromCharCode((v & 0xFF) >> 0) );
    if(outputToStream) {
        console.log("writer: writeInt16 flushing " + buf.toString("hex") );
        this.realOut.write(buf);
    } else {
        this.outputBuffer += buf;
    }
};

BinTreeNodeWriter.prototype.writeInt24 = function(v) {
    console.log("writeInt24 " + v);
    this.outputBuffer += Buffer( String.fromCharCode((v & 0xFF0000) >> 16) + String.fromCharCode((v & 0xFF00) >> 8) + String.fromCharCode((v & oxFF) >> 0));
};

BinTreeNodeWriter.prototype.writeListStart = function(i) {
    console.log("writeListStart " + i);
    if(i == 0) {
        this.outputBuffer += Buffer("\x00", "binary");
    } else if(i < 256) {
        this.outputBuffer += Buffer("\xF8", "binary"); // 248
        this.writeInt8(i);
    } else {
        this.outputBuffer += Buffer("\xF9", "binary"); // 249
        this.writeInt16(i);
    }
};

BinTreeNodeWriter.prototype.writeToken = function(intValue) {
    console.log("writeToken " + intValue + " " + String.fromCharCode(intValue));
    if(intValue < 245) {
        this.outputBuffer += Buffer(String.fromCharCode(intValue));
    } else if(intValue <= 500) {
        this.outputBuffer += Buffer("\xFE" + String.fromCharCode(intValue - 245)); // 254
    }
};

BinTreeNodeWriter.prototype.writeString = function(tag) {
    console.log("writeString tag=" + tag + "=" + this.tokenMap[tag]);
    var key = this.tokenMap[tag];
    if(key) {
        this.writeToken(key);
    } else {
        var atIndex = tag.indexOf('@');
        if(atIndex < 1) {
            console.error("atIndex < 1");
            //throw("atIndex < 1");
        } else {
            var server = tag.substr(atIndex + 1);
            var user = tag.substr(0, atIndex);
            this.writeJid(user, server);
        }
    }
};

BinTreeNodeWriter.prototype.writeJid = function(user, server) {
    console.log("writeJid " + user + "@" + server);
    this.outputBuffer += Buffer("\xFA", "binary"); // 250
    if(user) {
        this.writeString(user);
    } else {
        this.writeToken(0);
    }
    this.writeString(server);
};
